% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nauf_pmmeans.R
\name{nauf_pmmeans}
\alias{nauf_pmmeans}
\title{Predicted marginal means with \code{NA} unordered factor values.}
\usage{
nauf_pmmeans(object, vars, keep_level = NULL, drop_level = NULL,
  keep_group = NULL, drop_group = NULL, pairwise = TRUE)
}
\arguments{
\item{object}{A regression model fit with \code{\link{nauf_reg}} or a
reference grid created with \code{\link{nauf_grid}}.}

\item{vars}{A character vector specifying the names of variables included
in the model for which estimates are to be estimated for the full
interaction term.  At least one must be a factor.  See 'Details'.}

\item{keep_level}{A named list of character vectors specifying the levels
of factors which should be considered in the reference grid. See 'Details'.}

\item{drop_level}{A named list of character vectors specifying the levels
of factors which should not be considered in the reference grid.  See
'Details.'}

\item{keep_group}{A list of groups which should be considered in the
reference grid.  Any row in the grid which does not match at least one
group exactly is not considered.  See 'Details'.}

\item{drop_group}{A list of groups which should not be considered in the
reference grid.  Any row in the grid which matches at least one group
exactly is not considered.  See 'Details'.}

\item{pairwise}{A logical (default \code{TRUE}) indicating whether or not
pairwise comparisons for the group means should be computed.  If the
there is only one group mean, \code{pairwise} is ignored.}
}
\value{
An object of class \code{lsm.list} which inherits from \code{nauf}
  and contains one or more objects of class \code{lsmobj}.  See for
  \code{\link[lsmeans]{ref.grid-class}} and \code{\link[lsmeans]{summary}}
  for arguments to alter printing options, including the confidence level
  for means (default is 0.95), the p-value adjustment method for pairwise
  comparisons (default is "tukey"), and whether to give the results
  on the scale of the dependent variable, or whether to use the inverse
  link function (e.g. for logistic regression, whether results should be
  given in log-odds or probability). The object additionally has an attribute
  \code{specs} which is a list of the \code{vars}, \code{keep_level},
  \code{drop_level}, \code{keep_group}, and \code{drop_group} arguments
  passed in the call to \code{nauf_pmmeans}.
}
\description{
\code{nauf_pmmeans} computes predicted marginal means (also called
least-squares means, a term which is less generally applicable) for a factor
or an interaction involving factors in a model fit with \code{nauf_reg},
and optionally pairwise comparisons of these group means.  There are several
subsetting arguments which allow for the predictions to be generated over
only the relevant subset of the reference grid created by
\code{\link{nauf_grid}} (see 'Details').
}
\details{
First a description for the estimates generated when all elements of
\code{vars} are factors is given, and then the covariate estimates are
described.

Because, by design, certain factors in a regression fit with
\code{\link{nauf_reg}} are applicable only within subsets of the data,
using \code{\link[lsmeans]{lsmeans}} directly will generate and average
over estimates which are invalid.  \code{nauf_pmmeans} allows the user
to generate estimates for a factor (or factors) for only the subsets of the
data where the estimate makes sense.  The first argument, \code{object}, can
be either a model object fit with \code{\link{nauf_reg}} or a reference grid
made with \code{\link{nauf_grid}}.  If a model object is provided, the
funciton first calls \code{\link{nauf_grid}} to create a reference grid.
Depending on the type and complexity of the model, creating the reference
grid can be time-consuming, and so it is recommended that a reference
grid be created first, and used as the \code{object} argument, especially
when multiple calls to \code{nauf_pmmeans} will be made for the same model.

There are four ways to specify a subset of the reference grid to use in the
the computation of predicted marginal means, all of which default to
\code{NULL}, which indicates that the entire reference grid should be used.
If any of the factors specified in \code{vars} have \code{NA} values,
this will lead to incorrect estimates.

The \code{keep_level} argument, if specified, should be a named list
of character vectors, where the names of the vectors are the names of factors
in the regression, and the elements of the vectors are levels which should
be kept in the reference grid.  For each element in \code{keep_level},
any row which has a value for that factor (including \code{NA}) which is
not in the chacter vector is dropped from the reference grid.  The
\code{drop_level} argument works in the opposite way: any row which contains
the specified levels is dropped from the reference grid.

The \code{keep_group} argument, if specified, should be a list where each
element is a named list specifying the factor levels which define a group
of factor combinations which should be kept.  For each group entry (that is,
each element in the \code{keep_group} list), any row in the reference grid
which matches any combination of the factor levels in the group entry is
kept.  When there are multiple group entries in \code{keep_group}, any
reference grid row which matches at least one group is kept.  The
\code{drop_group} argument works in the opposte way: any row in the
reference grid which matches at least one group is dropped.

As an example, consider a situation where factor \code{f1} takes levels
\code{A} and \code{B}, and factor \code{f2} takes levels \code{C} and
\code{D} when \code{f1 = A}, but \code{f2 = NA} whenver \code{f1 = B}.  That
is, \code{f2} is only contrastive for the group \code{f1 = A}.  In this
case, calling \code{nauf_pmmeans} with \code{vars = "f2"}, but not
specifying any of the subsetting arguments, would generate mean estimates
for \code{f2} averaging over the groups \code{f1 = B, f2 = C} and
\code{f1 = B, f2 = D}, which are not real groups.  To avoid this, there
are several possible ways of subsetting.  You could specify
\code{keep_level = list(f1 = "A")}, or \code{drop_level = list(f1 = "B")},
or \code{keep_group = list(list(f1 = "A"))}, or
\code{drop_group = list(list(f1 = "B"))}.  Any of these specifications
would result in two estimates, one for \code{f2 = C} which corresponds
to \code{f1 = A, f2 = C}, and one for \code{f2 = D} which corresponds
to \code{f1 = A, f2 = D}.

Continuing with this example, the correct estimates for \code{f1} will
depend on the interpretation of \code{f2 = NA}.  If \code{f2 = NA} is
similar in interpretation to \code{f2 = C}, but is coded as \code{NA}
because \code{f1 = B, f2 = D} is not possible, then it would make sense
to compare the groups \code{f1 = A, f2 = C} and \code{f1 = B, f2 = NA}.
This is most easily accomplished by using the \code{drop_group} argument:
\code{drop_group = list(list(f1 = "B", f2 = c("C", "D")))}.  This doesn't
technically drop the non-existen groups \code{f1 = A, f2 = NA}, but this
won't affect the end result in this case because of the way \code{NA} values
are coded.  To explicitly drop this group (or similar groups when you aren't
sure whether leaving them in affects the outcome), you can do
\code{drop_group = list(list(f1 = "B", f2 = c("C", "D")), list(f1 = "A",
f2 = NA))}.  If \code{f2 = NA} cannot be interpreted as being similar to
to either \code{f2 = C} or \code{f2 = D}, then it makes sense to compare
\code{f1 = A}, averaging over \code{f1 = A, f2 = C} and \code{f1 = A, f2 = D},
to \code{f1 = B, f2 = NA}.  In this case, no subsetting arguments are
required (but may be used).

The recommended use of the subsetting arguments is to create a list of
of explicit group definitions for \code{keep_group} as its own object, and
then use the relevant elements of that list in calls to \code{nauf_pmmeans}.

If \code{vars} contains a combination of factors and covariates, then the
estimates generated are the slope for the full interaction of all of the
covariates in \code{vars} for each group in the full interaction of all of
the factors in \code{vars}.  As such, an error is thrown if \code{vars}
contains only covariates but no factors, or if \code{vars} includes
covariates but the full interaction of the variables listed in \code{vars}
is not in the model.  So, for example, for factor \code{f1} and covariates
\code{x1} and \code{x2}, with the full interaction \code{f1 * x1 * x2} in
the model, \code{vars = c("f1", "x1")} would return estimates (and optionally
pairwise comparisons) for the effect of an increase of 1 unit in \code{x1}
for each level of \code{f1} (excluding \code{NA} if \code{f1} has \code{NA}
values).  Calling \code{nauf_pmmeans} with  \code{vars = c("f1", "x1", "x2")}
would return the effect of the \emph{interaction term only} for each level
of \code{f1}; that is, the effect estimates would not include the main
effects of \code{x1} and \code{x2}.
}
\examples{
\dontrun{
# see 'Details' section for a description of the sample problem
# the recommended usage is demonstrated here
mod <- nauf_reg(y ~ f1 + f2, data = mydata)
rg <- nauf_grid(mod)
groups <- list()

groups$f2 <- list(list(f1 = "A", f2 = c("C", "D")))
f2_pmm <- nauf_pmmeans(rg, vars = "f2", keep_group = groups$f2)

# for the case where f2 = NA is similar in interpretation to f2 = C
groups$f1 <- list(
  A = list(f1 = "A", f2 = "C"),
  B = list(f1 = "B", f2 = NA))
f1_pmm <- nauf_pmmeans(rg, vars = "f1", keep_group = groups$f1)

# for the case where f2 = NA is not similar to f2 = C or f2 = D
groups$f1 <- list(
  A = list(f1 = "A", f2 = c("C", "D")),
  B = list(f1 = "B", f2 = NA))
f1_pmm <- nauf_pmmeans(rg, vars = "f1", keep_group = groups$f1)

# to compare all three possible groups
groups$f1_f2 <- list(
  A = list(f1 = "A", f2 = c("C", "D")),
  B = list(f1 = "B", f2 = NA)
f1_f2_pmm <- nauf_pmmeans(rg, vars = c("f1", "f2"),
  keep_group = groups$f1_f2)
}

}
\seealso{
\code{\link{nauf_grid}}
}

