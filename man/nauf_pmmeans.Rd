% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nauf_pmmeans.R
\name{nauf_pmmeans}
\alias{nauf_pmmeans}
\title{Predicted marginal means for \code{nauf} models.}
\usage{
nauf_pmmeans(object, specs, keep_level = list(), drop_level = list(),
  keep_group = list(), drop_group = list(), ...)
}
\arguments{
\item{object}{A \code{\linkS4class{nauf.ref.grid}} or any \code{nauf} model
(see \code{\link{is.nauf.model}}).  When a regression model is provided,
\code{\link{nauf_ref.grid}} is called first, and the result is used.
Creating the \code{\linkS4class{nauf.ref.grid}} can be time-consuming for
for mixed effects models, and so it is strongly suggested that a
\code{\linkS4class{nauf.ref.grid}} be created first, so that it can be
used for multiple calls to \code{nauf_pmmeans}.}

\item{specs}{A formula whose right hand side indicates variables for which 
predicted marginal means are to be computed.  Regardless of whether 
\code{*}, \code{:}, or \code{+} is used to separate the variables, the 
full interaction term is considered.  If the formula has a left hand side, 
it must be the key word \code{pairwise}, indicating that pairwise 
comparisons should be computed in addition to the predicted marginal means.}

\item{keep_level}{A named list of character vectors indicating factor levels 
in the reference grid which should be considered.  See 'Subsetting'.}

\item{drop_level}{A named list of character vectors indicating factor levels 
in the reference grid which should not be considered.  See 'Subsetting'.}

\item{keep_group}{A list whose elements are named lists of character vectors 
defining combinations of factor levels in the reference which should be 
considered.  See 'Subsetting'.}

\item{drop_group}{A list whose elements are named lists of character vectors 
defining combinations of factor levels in the reference which should not be 
considered.  See 'Subsetting'.}

\item{...}{Additional arguments. Currently unused and ignored with a warning.}
}
\value{
A \code{lsm.list} containing an element \code{pmmeans} and, if
  pairwise comparisons are made, a second element \code{contrasts}, both
  of which are \code{lsmobj} objects (see 
  \code{\link[lsmeans]{ref.grid-class}}).
}
\description{
\code{nauf_pmmeans} computes predicted marginal means (also called
least-squares means, a term which is less generally applicable) for a factor
or an interaction involving factors in a \code{nauf} regression model,
and optionally pairwise comparisons of these group means.  There are several
subsetting arguments which allow for the predictions to be generated over
only the relevant subset of the reference grid created by
\code{\link{nauf_ref.grid}}.  The function also allows covariates to be
included. See 'Subsetting', 'Factors', 'Covariates', and
'Factor-Covariate Interactions' for details.
}
\section{Subsetting}{

Because, by design, certain factors in a regression fit with
\code{\link{nauf_contrasts}} are applicable only within subsets of the data,
using \code{\link[lsmeans]{lsmeans}} directly will generate and average
over estimates which are invalid.  \code{nauf_pmmeans} allows the user
to generate predicted marginal means for only the subsets of the
data where the estimates make sense.  This is done through four subsetting
arguments, any combination of which can be used to specify the subset of
the reference grid over which to generate estimates:

\describe{
  \item{keep_level}{A named list where each element is a character vector of
    factor levels whose name is the name of the factor.  For example, 
    \code{keep_group = list(f1 = c("A", "B"), f2 = "C")} would indicate that 
    only the subset of the data where the factor \code{f1} is either \code{A} 
    or \code{B} and the factor \code{f2} is \code{C} should be considered.}
  \item{drop_level}{A named list with the same structure as \code{keep_level},
    but indicating factor levels which should \emph{not} be considered.  For 
    example, \code{drop_level = list(f1 = "A")} would indicate that rows in 
    the reference grid where the factor \code{f1} is \code{A} should not be 
    considered.}
  \item{keep_group}{A list whose elements are named lists with the same 
    structure as \code{keep_level} and \code{drop_level}.  For example, 
    \code{keep_group = list(list(f1 = "A", f2 = c("C", "D")), list(f1 = "B",
    f2 = c("D", "E")))}.  For each named list in \code{keep_group}, 
    \code{\link[base]{expand.grid}} is called.  Any row in the reference grid
    which pertains to one of the resulting groups is kept.  In this example, 
    using the format \code{f1:f2}, this would indicate that the groups 
    \code{A:C}, \code{A:D}, \code{B:D}, and \code{B:E} should be kept, and 
    all other combinations of these factors dropped.  Note that this 
    criterion applies to all of the indicated groups simultaneously.  If a 
    row of the reference grid belongs to a group specified in the first list 
    element of \code{keep_group} but not the second list element, the row 
    would still be kept.}
  \item{drop_group}{A list with the same structure as \code{keep_group}.  Any
    row of the reference grid which belongs to at least one of the groups 
    specified in \code{drop_group} is not considered.}
}

When all four subsetting arguments are empty lists (the default), all cells
in the reference grid are used (which makes sense for covariates, and for 
factors that are applicable with the same meaning throughout the dataset).  
For factors which contain \code{NA} values
in the original data frame, \code{NA} is treated as a level and should be
specified in the subsetting arguments without quotes.  The subsetting
arguments can also be used jointly in any combination.  Only observations
which meet the criteria of all subsetting arguments are used.

To give an example, consider the \code{\link{plosives}} dataset, and assume
we are interested in the model \code{cdur ~ dialect + spont}.
The \code{dialect} factor has levels \code{Cuzco}, \code{Lima}, and
\code{Valladolid}, and the \code{spont} variable is a logical indicating
whether the observation pertains to spontaneous (\code{TRUE}) or read
(\code{FALSE}) speech.  However, for the Valladolid speakers, there is
only spontaneous speech data, so we code \code{spont} as \code{NA} when
\code{dialect = Valladolid}.  The reference grid for this model (fit with
\code{\link{nauf_lm}}) will contain the combinations
\code{dialect = Cuzco, spont = NA}; \code{dialect = Lima, spont = NA};
\code{dialect = Valladolid, spont = TRUE}; and
\code{dialect = Valladolid, spont = FALSE}, even though these are not
real groups.  If we use no subsetting arguments and call \code{nauf_pmmeans}
with \code{specs = pairwise ~ dialect}, then the predicted marginal means
will be incorrect.  We want to compare the dialects conditioning on
spontaneous speech; i.e. we want to compare
\code{dialect = Cuzco, spont = FALSE}; \code{dialect = Lima, spont = FALSE};
and \code{dialect = Valladolid, spont = NA}. To do this, we could use either
of the follwing subsetting arguments (where \code{rg} is the 
\code{\linkS4class{nauf.ref.grid}} for the model):

\code{\preformatted{
# possibility 1
nauf_pmmeans(rg, pairwise ~ dialect, drop_group = list(
  list(dialect = "Valladolid", spont = c("TRUE", "FALSE")),
  list(dialect = c("Cuzco", "Lima"), spont = c("FALSE", NA))))

# possbility 2
nauf_pmmeans(rg, pairwise ~ dialect, keep_group = list(
  list(dialect = "Valladolid", spont = NA),
  list(dialect = c("Cuzco", "Lima"), spont = "TRUE")))
}}

Both of these possibilities will result in the same three predicted
marginal means in the \code{pmmeans} element, with pairwise comparisons
in the \code{contrasts} element of the returned \code{lsm.list}.  If we are
interested in the effect of \code{spont}, then the situation is substantially 
simpler. We just need to drop the Valladolid dialect and the \code{NA} values
for \code{spont}, which we could do with
\code{drop_level = list(dialect = "Valladolid", spont = NA)}.  See the
'Examples' section.
}

\section{Factors}{

When all variables in \code{specs} are factors, the full interaction term
is taken, and combinations of factor levels which are excluded by the
the subsetting arguments are dropped.  Predicted marginal means are then
computed as they are with \code{\link[lsmeans]{lsmeans}}, averaging over
only the relevant subset of the reference grid, and pairwise comparisons
for these means are computed as they are normally computed (if \code{specs}
has \code{pairwise} on the left hand side).
}

\section{Covariates}{

If \code{specs} indicates a single covariate, then the effect of an increase
of \code{1} in the value of the covariate is calculated as the \code{pmmean}.
If \code{specs} indicates multiple covariates, then the effect of a
simultaneous increase of \code{1} in the value of all of the covariates is
calculated as the \code{pmmean}.  In this case, pairwise comparisons are not
possible, as there is always one estimate.
}

\section{Factor-Covariate Interactions}{

If \code{specs} indicates a combination of factors and covariates, then
the effect of a simultaneous increase of \code{1} in the covariates for
each level of the interaction term of the factors is calculated.  If
\code{pairwise} is
used as the left hand side of \code{specs}, then pairwise comparisons for
the effect of the simultaneous increase of \code{1} in the covariates for
the different factor interaction levels are computed.
}
\examples{
dat <- droplevels(subset(plosives, voicing == "Voiceless"))
dat$spont[dat$dialect == "Valladolid"] <- NA
sdat <- standardize(cdur ~ dialect + spont, dat)
mod <- nauf_lm(sdat$formula, sdat$data)
rg <- nauf_ref.grid(mod)

## incorrect estimates
# averages over non-existent groups
dialect_wrong <- nauf_pmmeans(rg, pairwise ~ dialect)

# treats spont = NA values as a level and generates 3 pmmeans rather than 2
spont_wrong <- nauf_pmmeans(rg, pairwise ~ spont)

## correct estimates
dialect1 <- nauf_pmmeans(rg, pairwise ~ dialect, drop_group = list(
  list(dialect = "Valladolid", spont = c("TRUE", "FALSE")),
  list(dialect = c("Cuzco", "Lima"), spont = c("FALSE", NA))))

dialect2 <- nauf_pmmeans(rg, pairwise ~ dialect, keep_group = list(
  list(dialect = "Valladolid", spont = NA),
  list(dialect = c("Cuzco", "Lima"), spont = "TRUE")))

spont <- nauf_pmmeans(rg, pairwise ~ spont,
  drop_level = list(dialect = "Valladolid", spont = NA))

}
\seealso{
\code{\link{nauf_ref.grid}}, \code{\link[lsmeans]{lsmeans}}, and
  \code{\link[lsmeans]{ref.grid-class}}.
}

